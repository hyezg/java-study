## ch19. 자바의 역사와 JVM에 대해서 알아보자
자바의 역사
JDK의 플랫폼에 따른 차이
JDK, J2SE, Java SE 외에 자바에서 사용되는 다른 용어들
자바언어의 특징은 다음과 같다
자바의 버전별 차이
JIT 컴파일러는 도대체 뭘까?
HotSpot은 또 뭐야?
자바를 배우면 꼭 알아야 하는 용어
자바의 GC는 어떻게 진행되나요?


## ch20. 가장 많이 쓰는 패키지는 자바랭
#### - java.lang 패키지는 특별하죠
- java.lang : 유일하게 import없이 사용가능한 패키지.
  (String, System,Object,Class,Wrapper )
- 특징 :
  + 클래스는 import 하지 않고 사용할 수 O.
  + 기본형 타입을 객체로 변활시킬 때는 Wrapper클래스를 사용함.
 ##### - Object 클래스 : 모든 클래스의 최상위 클래스로 자바에서 생성된 모든 클래스의 상위 클래스로 지정됨.(하위 클래스에서 오버라이딩 가능함)
   - equals() : 서로 다른 두 객체,Object 타입을 비교하는 매서드.
   - toString() : 오버라이딩을 통해 클래스에 대한 정보를 출력
     + 클래스의 이름 + @ + 메모리 주소를16진법으로 전환한 문자열 표시함.(System.out.printf()로 출력한것과 동일)
   - hashCode() : 객체의 메모리 주소를 hash값으로 변환하는 함수를 적용한 결과를 돌려줌.(hash는 값을 일정한 함수에 따라 암호화 한 결과임)
     + 생성된 인스턴스가 저장되는 메모리의 주소를 hash값으로 변환 및 반환함.(@ 나옴)
     + toString() 값을 hashing 한 값을 반환함.
- Class :
  + 객체나 인터페이스의 런타임 상태를 저장함.
  + 객체는 클래스가 로드 될 때 자동으로 생성됨.
  + 객체를 명시적으로 선언할 수 X.
  + Object 클래스의 getClass() 메소드를 이용하여 Class 객체를 얻음.
 - forName() : 클래스명의 객체를 찾아 Class 클래스로 반환함.
 - genName() : 객체의 클래스명을 반환함.
 - newInstance() : 객체의 클래스 인스턴스를 생성하여 반환함.
 - getSuperclass() : 슈퍼 클래스명을 반환함.
 - getFields() : 클래스내에 변수드를 필드 리스트로 반환함.
- 숫자를 처리하는 클래스들
- 각종 정보를 확인하기 위한 System 클래스
- System.out을 살펴보자



## ch21. 실수를 방지하기 위한 제네릭이라는 것도 있어요
- 실수를 방지할 수 있도록 도와주는 제네릭
- 제네릭이 뭐지?
##### - 제네릭 : 모든 종류의 타입을 다룰 수 있도록, 클래스나 메소드를 타입 매개변수를 이용하여 선언하는 기법.
           클래스 코드를 찍어내듯이 생산할 수 있도록 일반화시키는 도구.(c++의 템플릿과 동일함)
- 제네릭 타입의 이름 정하기
- StackP<E> : E에 구체적인 타입을 지정해 다룰 수 있는 구체화된 스택. ex) Stack<Integer> : Integer타입만 다루는 스택.
  + E : Element를 의미하며 컬렉션의 요소임을 나타냄.
  + T : Type을 의미
  + V : Value
  + K : Key
- Vector<E> : 배열을 가변크기로 다룰 수 있게 하고, 객체의 삽입, 삭제, 이동이 쉽도록 구성한 컬렉션 클래스.
  + 삽입되는 요소의 개수에 따라 자동으로 크기를 조절하고 요소의 삽입과 삭제에 따라 자동으로 요소들의 자리를 이동함.
- 백터 생성 : E에 요소로 사용할 타입을 지정해야함, int/char/double 등의 기본 타입은 E에 사용X.
. <E>에 올 수 없는 것은?
. 기본타입 int, char, double
  
  + null 삽입 할 수 O.
```java
Vector<Integer> v = new Vector<Integer>;
Vector<Integer> v = new Vector<Integer>(5); //백터의 용량 설정하는 법
```
- 주요 메소드


| 메소드 | 설명 |
|---| --- | 
| boolean add(E element) | 백터의 맨 뒤에 요소 추가 |
| void add(int index, E element) | 인덱스에 요소 삽입 |
| int capacity() | 벡터의 현재 용량 리턴 | 
| void clear() | 벡터의 모든 요소 삭제 |
| E get(int index) | 인덱스의 요소 리턴 |
| E remove(int index) | 인덱스의 요소 리턴 |
| int size() | 벡터가 포함하는 요소의 개수 리턴 |

- 요소 삽입
```java
v.add(Integer.valueOf(5));
v.add(5);          //자동 박싱됨
v.add(2,5);   
```

- 제네릭에 ?가 있는 것은 뭐야?
- 제네릭 선언에 사용하는 타입의 범위도 지정할 수 있다
- 메소드를 제네릭하게 선언하기
- 제네릭의 장점 :
  + 동적으로 타입이 결정되지 않고 컴파일 시에 타입이 결정되므로 보다 안전한 프로그래밍 가능.
  + 런타임 타입 충돌 문제 방지
  + 개발 시 타입 캐스팅 절차 불필요
  + ClassCastException 방지
  . 제니릭의 장점은?
  . 동적으로 타입이 결정되지 않고 컴파일 시에 타입이 결정되므로 보다 안전한 프로그래밍 가능/런타임 타입 충돌 문제 방지/개발 시 타입 캐스팅 절차 불필요/ClassCastException 방지

