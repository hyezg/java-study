## ch19. 자바의 역사와 JVM에 대해서 알아보자
자바의 역사
JDK의 플랫폼에 따른 차이
JDK, J2SE, Java SE 외에 자바에서 사용되는 다른 용어들
자바언어의 특징은 다음과 같다
자바의 버전별 차이
JIT 컴파일러는 도대체 뭘까?
HotSpot은 또 뭐야?
자바를 배우면 꼭 알아야 하는 용어
자바의 GC는 어떻게 진행되나요?


## ch20. 가장 많이 쓰는 패키지는 자바랭
#### - java.lang 패키지는 특별하죠
- java.lang : 유일하게 import없이 사용가능한 패키지.
  (String, System,Object,Class,Wrapper )
- 특징 :
  + 클래스는 import 하지 않고 사용할 수 O.
  + 기본형 타입을 객체로 변활시킬 때는 Wrapper클래스를 사용함.
  . java.lang 의 특징은?
  . import 없이 사용가능한 패키지
 ##### - Object 클래스 : 모든 클래스의 최상위 클래스로 자바에서 생성된 모든 클래스의 상위 클래스로 지정됨.(하위 클래스에서 오버라이딩 가능함)
   - boolean equals() : 서로 다른 두 객체,Object 타입을 비교하는 매서드.
   - toString() : 오버라이딩을 통해 클래스에 대한 정보를 출력
     + 클래스의 이름 + @ + 메모리 주소를16진법으로 전환한 문자열 표시함.(System.out.printf()로 출력한것과 동일)
   - hashCode() : 객체의 메모리 주소를 hash값으로 변환하는 함수를 적용한 결과를 돌려줌.(hash는 값을 일정한 함수에 따라 암호화 한 결과임)
     + 생성된 인스턴스가 저장되는 메모리의 주소를 hash값으로 변환 및 반환함.(@가 나옴)
     + toString() 값을 hashing 한 값을 반환함.
- Class 클래스 :
  + 객체나 인터페이스의 런타임 상태를 저장함.
  + 객체는 클래스가 로드 될 때 자동으로 생성됨.
  + 객체를 명시적으로 선언할 수 X.
  + Object 클래스의 getClass() 메소드를 이용하여 Class 객체를 얻음.
 - forName() : 클래스명의 객체를 찾아 Class 클래스로 반환함.
 - genName() : 객체의 클래스명을 반환함.
 - newInstance() : 객체의 클래스 인스턴스를 생성하여 반환함.
 - getSuperclass() : 슈퍼 클래스명을 반환함.
 - getFields() : 클래스내에 변수드를 필드 리스트로 반환함.


##### - 숫자를 처리하는 클래스들
- java.lang.Math : Math 클래스는 생성자가 없음.두 개의 상수와 메소드들로 이루어져 있다.
- java.math.BigInteger :
- java.math.BigDecimal :
- Wrapper 클래스 : 기본타입의 값을 갖는 객체를 포장객체라고함. 내부의 값을 외부에서 변경이 불가능해서 변경하고싶다면 새로운 포장 객체를 만들어야함.
- 박싱과 언박싱 : 박싱은 기본타입의 값을 포장 객체로 만드는 과정. 언박싱은 반대.
- 자동 박싱 : 포장 클래스 타입에 기본값이 대입될 경우 발생함.
- 자동 언박싱 : 기본 타입에 포장 객체가 대입되는 경우와 연산에서 발생함.
- 문자열을 기본 타입 값으로 변환 :
  + int형 : Integer.pareseInt("10");
  ) int형을 문자열로 바꿀려면 ?
  ) Integer.parseInt("10");
- 각종 정보를 확인하기 위한 System 클래스
- System.out을 살펴보자


## ch21. 실수를 방지하기 위한 제네릭이라는 것도 있어요
- 실수를 방지할 수 있도록 도와주는 제네릭
- 제네릭이 뭐지?
##### - 제네릭 : 모든 종류의 타입을 다룰 수 있도록, 클래스나 메소드를 타입 매개변수를 이용하여 선언하는 기법/ 데이터의 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법.(외부 사용자에 의해 지정됨)
           클래스 코드를 찍어내듯이 생산할 수 있도록 일반화시키는 도구.(c++의 템플릿과 동일함)
- 제네릭 타입의 이름 정하기
- StackP<E> : E에 구체적인 타입을 지정해 다룰 수 있는 구체화된 스택. ex) Stack<Integer> : Integer타입만 다루는 스택.
- 타입
  + E : Element를 의미하며 컬렉션의 요소임을 나타냄.
  + T : Type을 의미
  + V : Value
  + K : Key
- Vector<E> : 배열을 가변크기로 다룰 수 있게 하고, 객체의 삽입, 삭제, 이동이 쉽도록 구성한 컬렉션 클래스.
  + 삽입되는 요소의 개수에 따라 자동으로 크기를 조절하고 요소의 삽입과 삭제에 따라 자동으로 요소들의 자리를 이동함.
- 백터 생성 : E에 요소로 사용할 타입을 지정해야함, int/char/double 등의 기본 타입은 E에 사용X.
. <E>에 올 수 없는 것은? (타입 파라미터에)
. 기본타입 int, char, double (오직 참조타입만 가능)
  
  + null 삽입 할 수 O.
```java
Vector<Integer> v = new Vector<Integer>;
Vector<Integer> v = new Vector<Integer>(5); //백터의 용량 설정하는 법
```
- 주요 메소드
| 메소드 | 설명 |
|---| --- | 
| boolean add(E element) | 백터의 맨 뒤에 요소 추가 |
| void add(int index, E element) | 인덱스에 요소 삽입 |
| int capacity() | 벡터의 현재 용량 리턴 | 
| void clear() | 벡터의 모든 요소 삭제 |
| E get(int index) | 인덱스의 요소 리턴 |
| E remove(int index) | 인덱스의 요소 리턴 |
| int size() | 벡터가 포함하는 요소의 개수 리턴 |
) capacity() 는 무엇?
) 벡터의 현재 용량 리턴함

  
- 요소 삽입
```java
v.add(Integer.valueOf(5));
v.add(5);          //자동 박싱됨
v.add(2,5);   
```

- 제네릭에 ?가 있는 것은 뭐야?
- 물음표 = 와일드카드 : 어떤 타입이든 될 수 있음.(타입 한정 연산자와 함께 쓰임)
- <?> : 모든 타입 가능
- <? extends U> : 상위 클래스 제한(u와 그자손들만) ,공변성 적용
- <? super U> : 하위 클래스 제한(u와 그 조들만), 반공변성 적용
  (공변성 : 서로 다른 타입간에 함께 변할 수 있다는 특징)

- 제네릭 선언에 사용하는 타입의 범위도 지정할 수 있다
- 메소드를 제네릭하게 선언하기
- 제네릭의 장점 :
  + 동적으로 타입이 결정되지 않고 컴파일 시에 타입이 결정되므로 보다 안전한 프로그래밍 가능.
  + 런타임 타입 충돌 문제 방지
  + 개발 시 타입 캐스팅 절차 불필요
  + ClassCastException 방지
  . 제니릭의 장점은?
  . 동적으로 타입이 결정되지 않고 컴파일 시에 타입이 결정되므로 보다 안전한 프로그래밍 가능/런타임 타입 충돌 문제 방지/개발 시 타입 캐스팅 절차 불필요/ClassCastException 방지
- 클래스에서 지정한 제네릭 유형과 별도로 메소드에서 독립적으로 제네릭 유형을 선언하여 쓸 수 O.
- 위의 방식이 필요한 이유 : 정적메소드로 선언할 때 필요함.(static 메소드는 이미 메모리에 올라가 있기 때문에 클래스 이름을 통해 바로 쓸 수 있)

