## ch09. 자바를 배우면 패키지와 접근 제어자는 꼭 알아야 해요
- 패키지의 필요성 : 여러명에서 자바 프로그램을 개발하는 경우 동일한 이름의 클래스가 존재할 수 O, 합칠 때 오류 발생함
    -> 이름 공간(name space)때문
##### - 패키지 : 서로 관련된 클래스와 인터페이스의 컴파일 된 클래스파일들을 하나의 디렉터리에 묶어 놓은 것.
- 모듈 : 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
  - 목적 : 자바 api를 여러 모듈로 분할하여 응용프로그램의 실행에 적합한 모듈들로만 실행 환경을 구축하기 위함.
 
- 패키지 사용 = import문
  + 다른 패키지에 작성된 클래스 사용 :
    + import 이용 X : 소스 내에서 패키지 이름과 클래스 이름의 전체 경로명을 써줘야함. ex) java.util.Scanner sc = new java.util.Scanner(System.in);
    + import 이용 : 소스의 시작부분에 패키지명 명시 ex) import java.util.Scanner;(특정 클래스만), import java.util.*;(모든 클래스 포함)

- 패키지 만들기 : package 패키지명;

- 디폴트 패키지 : package선언문 없이 만들어진 클래스의 패키지.(디폴트 패키지는 현재 디렉터리)
- 패키지 특징 :
  + 패키지 계층 구조
  + 패키지별 접근 제한
  + 동일한 이름의 클래스와 인터페이스의 사용 가능
- 주요 패키지
  + java.lang : 자바 language 패키지 - 스트링,수학함수,입출력 등 기본적인것들. (자동으로 import됨)
  + java.util : 자바 유틸리티 패키지 - 날짜,시간,벡터,해시맵 등 클래스와 인터페이스 제공.
  + java.io : 키보드,모니터,프린터,디스크 등에 입출력 할 수 있는 클래스와 ㅇ인터페이스 제공
  + java.awt : 자바 gui프로그래밍을 위한 클래스와 인터페이스 제공

- Object 클래스
  - 특징 : java.lang 패키지에 포함됨, 모든클래스의 슈퍼 클래스-모든 클래스에 강제 상속, 모든 객체가 공통으로 가지는 객체의 속성을 나타내는 메소드 보유함

##### Q) java.lang 패키지에 포함된 대표적인 클래스는 ? 
-> Object 클래스 <p>
- 주요 메소드 :
```java
boolean equals(Object obj); //obj가 가리키는 객체와 현재 객체를 비교하여 같으면 true리턴함.
Class getClass(); // 현 객체의 런타임 클래스를 리턴
int hashCode(); //현 객체에 대한 해시 코드 값 리턴
String toString(); // 현 객쳉에 대한 문자열 표현을 리턴
void notify(); // 현 객체에 대해 대기하고 있는 하나의 스레드를 깨움
void notifyAll(); // 현 객체에 대해 대기하고 있는 모든 스레드를 깨움
void wait(); // 다른 스레드가 깨울 때까지 현재 스레드를 대기하게 함
```
- StringBuffer 클래스 : 가변크기의 문자열 저장 클래스.
    - Java.lang.StringBuffer
    - String 클래스와 달리 문자열 변경 가능
    - StringBuffer 객체의 크기는 스트링 길이에 따라 가변적
    - 생성 : StringBuffer sb = new StringBuffer("java);
    - 주요 메소드 : StringBuffer append(String str) : str스트링을 스트링 버퍼에 덧붙임.
- Calendar 클래스 : java.util 패키지, 시간과 날짜 정보 저장 관리
    - 생성 : Calendar d = Calendar.getInstnace();
#### - 객체 배열
```java
Circle [] c;    //Circle배열에 대한 레퍼런스 변수 c 선언
c = new Circle[5];    // 레퍼런스 배열 생성
for(int i=0; i<c.length; i++)    {   //c.length = 5
    c[i] = new Circle(i);    //배열의 각 원소 객체 생성
}

for(int i=0; i<c.length; i++)    //배열에 있는 모든 Circle객체의 면적 출력
    System.out.println((int)c[i].getArea()+" ");
```  
#### - 접근 제어자(접근 지정자) : private, portected, public, 디폴트(접근지정자 생략)
    - 목적 : 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용한하기 위해서.
            객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
##### - 공개 범위 : private < 디폴트 < protected < public
      완벽 차단 | 동일 패키지 허용 | 동일 패키지,자식클래스에 허용 | 모든 클래스에 허용
##### Q) 접근 제어자의 공개 범위가 작은순서대로 쓰세요.
-> private < 디폴트 < protected < public <p>

- 클래스 접근 지정
    - 다른 클래스에서 사용O,X 허용 지정
    - public 클래스 : 다른 모든 클래스에게 접근 허용
    - 디폴트 클래스 : (=package-private) 같은 패키지의 클래스에만 허용(다른 패키지 X)
- 멤버 접근 지정
    + public 멤버 :  모든 클래스 허용.
    + private 멤버 : 동일 클래스 내에만 허용, 상속받은 서브 클래스에서 접근 불가.
    + protected 멤버 : 같은 패키지내의 다른 모든 클래스에게 허용.
    + 디폴트 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용.

##### Q) 디폴트 클래스는 다른 패키지의 클래스를 허용한다.(o,x)
-> X <p>

- static 멤버와 non-static 멤버
- non-static 멤버의 특성(= 인스턴스 멤버) :
    - 공간적 특성 : 멤버들은 객체마다 독립적으로 별도 존재 , 인스턴스 멤버라고도 부름.
    - 시간적 특성 : 필드와 메소드는 객체 생성 후 비로소 사용 가능.
    - 비공유 특성 : 멤버들은 다른 객체에 의해 공유되지 않고 베타적.<p>
- static 멤버(= 클래스 멤버,정적 멤버) :
    - 객체마다 생기는것 X, 클래스당 하나만 생성됨, 객체를 생성하지 않고 사용가능.
    - 특성 :
        - 공간적 특성 : static 멤버들은 클래스 당 하나만 생성.
        - 시간적 특성 : static 멤버들은 클래스가 로딩될 때 공간 할당.
        - 공유의 특성 : static 멤버들은 동일한 클래스의 모든 객체에 의해 공유.
- 정적 변수 : 모든 객체에 공통인 변수. 하나의 클래스에 하나만 존재함.
- 정적 메소드(static ~) : ex) public static int getCount() {}
    - 정적메소드 제약조건 : this사용 불가(객체 없이 사용가능하기때문)
##### Q) 정적메소드에서 this를 사용할 수 없는 이유는? 
-> 객체 없이 사용가능하기때문. <p>

```java
class StaticSample {
    int n;    //non-static 필드
    void g()    {}    //non-static 메서드
    static int m;    //static 필드
    static void f()    {}    //static 메서드
}
```
- final 필드 : 상수 선언할 때 사용. ex) public static final double PI=3.14;
    - 선언 시 초기값을 지정해야함.
    - 실행 중에 값 변경X
<p>

## ch10. 자바는 상속이라는 것이 있어요
- 상속(inheritance) : 객체 지향의 상속-부모클래스에 만들어진 필드,메소드를 자식클래스가 물려받음, 상속을 통한 간결한 자식클래스 작성
- 상속의 장점 : 클래스의 간결화,클래스 관리 용이, 소프트웨어의 생상성 향상
- 상속 선언 : extends 키워드 사용 ( 부모클래스(super클래스), 자식클래스(sub클래스) )
```java
public class Person {}
public class Student extends Person {}    //Person을 상속받는 클래스 Student 선언
```
    
##### Q) 상속의 장점은?
-> 클래스의 간결화,클래스 관리 용이, 소프트웨어의 생상성 향상
    
- 상속의 특징
    - 클래스의 다중 상속X
    - 상속 횟수 무제한
    - 상속의 최상위 조상 클래스는 java.lang.Object클래스
##### Q) 상속의 최상위 조상 클래스는 무엇?
-> java.lang.Object 클래스

- 상속에서의 접근지정자 4개
  - 슈퍼클래스의 private 멤버 : 다른 모든 클래스에 접근 불허, 클래스내의 멤버들에게만 접근허용
  - 슈퍼클래스의 디폴트 멤버 : 패키지내 모든 클래스에 접근 허용, (같은 패키지 안에 있으면 ok)
  - 슈퍼클래스의 public 멤버 : 다른 모든 클래스에 접근 허용
  - 슈퍼클래스의 protected 멤버 : 같은 패키지내의 모든 클래스 접근 허용, 다른 패키지에 있어도 서브클래스는 슈퍼클래스의 procted멤버 접근 가능
* 슈퍼&서브 패키지가 동일한 패키지에 있는 경우 : public, 디폴트, procted O / private X
* 슈퍼&서브 패키지가 서로 다른 패키지에 있는 경우 : public, procted O / 디폴트, private X

- 서브클래스에서 슈퍼클래스의 생성자 선택
    - 상속 관계에서의 생성자 : 슈퍼클래스와 서브 클래스 각각 여러 생성자 O
    - 서브클래스 생성자 작성 원칙 : 서브클래스 생성자에서 슈퍼클래스 생성자 하나 선택
    - 서브클래스에서 슈퍼클래스의 생성자를 선택X 경우 : 컴파일러가 자동으로 슈퍼클래스의 기본 생성자 선택
    - 서브클래스에서 슈퍼클래스의 생성자를 선택할 때 : super() 이용
  - super() : 서브클래스에서 명시적으로 슈퍼클래스의 생성자 선택 호출 -> super(parameter);
*서브클래스 생성자 코드의 제일 첫 라인에 와야함.
##### - 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브클래스에서 재정의 : 슈퍼클래스 메소드의 이름,매개변수 타입 및 개수, 리턴 타입 등 모든 것 동일하게 작성,
                    동적 바인딩(서브 클래스에 오버라이딩된 메소드가 무조건 실행되는) 발생
- 오버라이딩 목적 : 슈퍼클래스에 선언된 메소드를 각 서브클래스들이 자신들의 내용으로 바꿔서 새로 구현 가능.
                  상속을 통해 '하나의 인터펭이스(같은 이름)에 서로 다른 내용 구현' 이란 객체 지향의 다형성 실현.
- 동적 바인딩 : 실행할 메소드를 실행 시에 결정. 오버라이딩메소드가 항상 호출.
#### 동적바인딩 이해하기,,

- 메소드 재정의(오버라이딩) : 자식클래스가 상속된 부모클래스의 메소드를 다시 정의 하는 것.
- 
## ch11. 모든 클래스의 부모 클래스는 Object에요
- Object 클래스
  - 특징 : java.lang 패키지에 포함됨, 모든클래스의 슈퍼 클래스-모든 클래스에 강제 상속, 모든 객체가 공통으로 가지는 객체의 속성을 나타내는 메소드 보유함

##### Q) java.lang 패키지에 포함된 대표적인 클래스는 ? 
-> Object 클래스 <p>
- 주요 메소드 :
```java
boolean equals(Object obj); //obj가 가리키는 객체와 현재 객체를 비교하여 같으면 true리턴함.
Class getClass(); // 현 객체의 런타임 클래스를 리턴
int hashCode(); //현 객체에 대한 해시 코드 값 리턴
String toString(); // 현 객쳉에 대한 문자열 표현을 리턴
void notify(); // 현 객체에 대해 대기하고 있는 하나의 스레드를 깨움
void notifyAll(); // 현 객체에 대해 대기하고 있는 모든 스레드를 깨움
void wait(); // 다른 스레드가 깨울 때까지 현재 스레드를 대기하게 함
```
